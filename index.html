<!doctype html><meta charset=utf-8>

<meta name=viewport content="width=device-width, height=device-height, initial-scale=1">

<style>
	table, td, th {
		border: 2px solid black;
		border-collapse: collapse;
	}
	td, th {
		padding: 0;
		font-family: sans-serif;
	}
	th {
		background: #CDF;
		padding: .25em .5em;
	}
	
	table { border-width: 4px; }
	th, td { border-bottom-width: 5px; }
	th:nth-child(1), th:nth-child(2) { min-width: 10em;}
	
	td span {
		display: inline-block;
		padding: .25em .5em;
	}
	td button { }
	
	.present { font-family: serif; }
	.filename-rom.missing { background: #FAA; text-align: center; }
	.filename-rom.missing:before { content: "(missing)"; }
	
	.filename-patch.missing { background: #CCC; text-align: center; }
	.filename-patch.missing:before { content: "(none)"; }
	.filename-patch.unmatched { background: #FAA; }
	
	.crc {
		font-family: monospace;
		padding: .25em .25em;
		word-spacing: -50%;
		display: flex;
	}
	.crc > span:first-child {
		flex-grow: 1;
	}
	
	file-label {
		display: block;
	}
</style>

<!--<script src="js/locale.js"></script>-->
<script src="js/MarcFile.js"></script>
<script src="js/crc.js"></script>
<script src="js/formats/ips.js"></script>
<!--
<script src="js/formats/ups.js"></script>
<script src="js/formats/aps.js"></script>
<script src="js/formats/bps.js"></script>
<script src="js/formats/rup.js"></script>
<script src="js/formats/ppf.js"></script>
<script src="js/formats/pmsr.js"></script>
	  <script src="js/formats/vcdiff.js"></script>
-->
<script src="js/zip.js/zip.js"></script>
<script src="js/zip.js/inflate.js"></script>

<input type=file multiple id=$file>
<hr>
<table id=$table>
	<tr>
		<th> rom file <th> patch file <th> output
	<tbody id=$item_list>
</table>

<script>
	zip.useWebWorkers = false
	
	let files = {__proto__:null}
	let patches = {__proto__:null}
	let items = []
	function add(f) {
		let [match, base_name, ext] = /^([^]*?)(\.[^.]+)?$/i.exec(f.name)
		let map
		f.base_name = base_name
		if (ext && ext.toLowerCase()=='.ips') {
			patches[base_name] = f
			f.label = draw_label(f, 'patch')
			f.ips = true
		} else {
			files[base_name+(ext||"")] = f
			f.label = draw_label(f, 'rom')
		}
	}
	
	$file.onchange = e=>{
		for (let f of e.target.files) {
			if (f.type=='application/zip'){
				zip.createReader(
					new zip.BlobReader(f),
					z=>{
						z.getEntries(entries=>{
							for (let e of entries) {
								e.name = e.filename
								e.size = e.uncompressedSize
								add(e)
							}
							draw()
						})
					},
					z=>alert("error loading .zip")
				)
			} else {
				let m = new MarcFile(f, e=>{
					m.crc32 = crc32(m)
					draw_label(m, m.ips ? 'patch' : 'rom', m.label)
				})
				m.name = f.name
				m.size = f.size
				add(m)
			}
		}
		draw()
	}
	
	function draw_label(file, type, cell = document.createElement('file-label')) {
		cell.x_file = file
		cell.textContent = ""
		cell.draggable = true
		cell.className = "filename filename-"+type
		if (!file) {
			cell.className += ' missing'
		} else {
			cell.dataset.name = file.name
			cell.className += ' present'
			let lbl = document.createElement('span')
			lbl.textContent = file.name
			let btn = document.createElement('button')
			btn.textContent = "❌"
			cell.append(btn, lbl)
			
			let e = document.createElement('div')
			let a = document.createElement('span')
			if (file.size>1000)
				a.textContent = (file.size/1024).toFixed(1)+"K"
			else
				a.textContent = file.size+"B"
			let b = document.createElement('span')
			if (file.crc32)
				b.textContent = ("00000000"+file.crc32.toString(16)).slice(-8).replace(/..(?!$)/g, "$& ")
			e.append(a,b)
			e.className = 'crc'
			cell.append(e)
			
			btn.onclick = e=>{
				if (type=='rom')
					delete files[file.name]
				else
					delete patches[file.base_name]
				file.label.remove()
			}
		}
		return cell
	}
	
	function group(files, patches) {
		let used = {__proto__:null}
		let items = []
		// find the patch file for each rom
		for (let name in files) {
			let file = files[name]
			let patch = patches[file.name] || patches[file.base_name]
			items.push({rom: file, patch: patch})
			if (patch)
				used[patch.base_name] = true
		}
		// add any unused patch files
		for (let base_name in patches) {
			if (!used[base_name])
				items.push({rom:null, patch:patches[base_name]})
		}
		return items
	}
	
	let dragging
	function dropzone(cell) {
		cell.ondragenter = ev=>{
			if ([...event.dataTransfer.items].find(x=>x.type=='text/x-drag'))
				event.preventDefault()
		}
		cell.ondragover = ev=>{
			ev.dataTransfer.dropEffect = 'move'
			ev.preventDefault()
		}
		cell.ondrop = ev=>{
			if (dragging && ev.dataTransfer.getData('text/x-drag')) {
				let d = dragging
				dragging = null
				let p = d.parentNode
				if (cell.firstChild) {
					if (!p) return
					p.append(cell.firstChild)
				}
				cell.append(d)
			}
		}
	}
	
	$table.ondragstart = ev=>{
		if (ev.target.tagName=='FILE-LABEL') {
			dragging = ev.target
			ev.dataTransfer.setData('text/x-drag', 1)
			ev.dataTransfer.effectAllowed = 'move'
		}
	}
	
	function draw() {
		items = group(files, patches)
		
		$item_list.textContent = ""
		for (let item of items) {
			let row = $item_list.insertRow()
			let cell1 = row.insertCell()
			let cell3 = row.insertCell()
			let cell4 = row.insertCell()
			dropzone(cell1)
			dropzone(cell3)
			if (item.rom)
				cell1.append(item.rom.label)
			if (item.patch)
				cell3.append(item.patch.label)
			let btn = document.createElement('button')
			btn.textContent = 'apply'
			cell4.append(btn)
			btn.onclick = e=> {
				btn.disabled = true
				let rom = cell1.firstChild
				let patch = cell3.firstChild
				if (rom && patch) {
					rom = rom.x_file
					patch = patch.x_file
					apply(rom, patch, out=>{
						window.saveAs = (blob, n)=>{
							let a = document.createElement('a')
							a.href = URL.createObjectURL(blob)
							a.download = item.rom.name
							a.textContent = 'download'
							//URL.revokeObjectURL(a.href)
							btn.replaceWith(a)
						}
						out.save()
					})
				}
			}
		}
	}
	// hm maybe we could allow dragging items around in the table...
	
	function apply(rom, patch, cb) {
//		let ready=0
//		let rom, patch
//		let load = ()=>{
//			if (++ready==2) {
				let ips = parseIPSFile(patch)
				let out = ips.apply(rom)
				cb(out)
//			}
//		}
		//rom = new MarcFile(rom, load)
		//patch = new MarcFile(patch, load)
	}
</script>
